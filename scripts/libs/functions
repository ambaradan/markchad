#!/bin/env bash

function divider() {
  printf -- "-%.0s" $(seq 1 80)
  printf "\n"
}
function indent() {
  local indentSize=2
  local indent=1
  if [ -n "$1" ]; then indent=$1; fi
  pr -to $((indent * indentSize))
}
  # Loop until a key is pressed
function press_to_exit() {
  while true; do
    read -rsn1 key # Read a single character silently
    if [[ -n "$key" ]]; then
      printf "\n"
      exit
    fi
  done
}
# Function to center text and format to 60 columns
center_and_format_text() {
    local text="$1"
    local terminal_width=80  # Set terminal width to 60 columns
    local wrapped_text
    wrapped_text=$(echo "$text" | fold -s -w $terminal_width)  # Wrap text
    while IFS= read -r line; do
        local line_length=${#line}
        local padding=$(( (terminal_width - line_length) / 2 ))  # Calculate padding
        printf "%${padding}s%s\n" "" "$line"  # Print the centered line
    done <<< "$wrapped_text"
}
format_text() {
    local text="$1"
    # Fold the text at 80 columns and add two spaces padding on each side
    echo "$text" | fold -s -w 76 | sed 's/^/  /; s/$/  /'
}
# Title
title_msg() {
  termwidth=80
  padding="$(printf '%0.1s' ={1..500})"
  printf "%*.*s ${bold_in}${orange}%s${clear}${bold_out} %*.*s\n" 0 "$(((termwidth-2-${#1})/2))" "$padding" "$1" 0 "$(((termwidth-1-${#1})/2))" "$padding"
}
section_title() {
  termwidth=80
  padding="$(printf '%0.1s' _{1..500})"
  printf "\n%*.*s ${bold_in}${blue}%s${clear}${bold_out} %*.*s\n\n" 0 "$(((termwidth-2-${#1})/2))" "$padding" "$1" 0 "$(((termwidth-1-${#1})/2))" "$padding"
}
warning_title() {
  termwidth=80
  padding="$(printf '%0.1s' ={1..500})"
  printf "%*.*s ${bold_in}${red}%s${clear}${bold_out} %*.*s\n" 0 "$(((termwidth-2-${#1})/2))" "$padding" "$1" 0 "$(((termwidth-1-${#1})/2))" "$padding"
}
justify_text() {
    # Get the length of the longest line
    max_length=$(wc -L < "$1")

    # Loop through each line in the file
    while read -r line; do
        # Calculate the number of spaces needed to justify the line
        num_spaces=$((max_length - ${#line}))

        # Add two spaces to the beginning and end of the line
        line="  $line  "

        # Add the necessary number of spaces to justify the line
        for ((i=0; i<num_spaces; i++)); do
            line=" $line"
        done

        # Print the justified line
        echo "$line"
    done < "$1"
}
