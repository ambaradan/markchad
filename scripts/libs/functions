#!/bin/env bash
# Used only locally to eliminate ShellChek warnings
source ./messages
# Function to back up directories
# Variable Colors
export green='\e[32m'
export blue='\x1b[38;5;81m'
export orange='\x1b[38;5;214m'
export red='\033[0;31m'
export clear='\e[0m'
export bold_in='\033[1m'
export bold_out='\033[0m'
# Function to check Neovim version
function check_neovim_version() {
  # Check if Neovim is installed
  if command -v nvim &>/dev/null; then
    # Get the path of the Neovim executable
    nvim_path=$(command -v nvim)

    # Extract the version number
    nvim_vers="$(nvim --version | head -1)"
    nvim_version=$(echo "$nvim_vers" | tr -cd '[:digit:].')
    # Minimum required version
    nvim_req="0.10.0"
    # Print the path of the Neovim executable
    printf "Neovim executable path: ${bold_in}%s${bold_out}\n" "$nvim_path" | indent 2

    # Compare versions
    if [[ $(printf '%s\n' "$nvim_version" "$nvim_req" | sort -V | head -n 1) = "0.10.0" ]]; then
      printf "Neovim version is ${bold_in}%s${bold_out} ${bold_in}CHECK PASSED${bold_out}\n" "$nvim_version" | indent 2
      return 0
    else
  warning_bar "$warning - Version Outdated"
  format_text "$nv_vers_req"
  printf "\n"
  printf "%s ${bold_in}%s${bold_out}" "$nv_required" "$nvim_req" | indent 8
  printf "%s ${bold_in}%s${bold_out}" "$nv_installed" "$nvim_version" | indent 8
  # Neovim Documentation
  printf "\n${bold_in}%s${bold_out}\n\n" "$neovim_title" | indent 3
  printf "${bold_in}%s${bold_out}" "$neovim_install" | indent 5
  printf "${bold_in}%s${bold_out}\n\n" "$neovim_build" | indent 5
  # --------------------
  exit 1
    fi
  else
    warning_bar "WARNING - No Neovim Found"
    format_text "$nv_check_no"
    # Neovim Documentation
    printf "\n"
    printf "${bold_in}%s${bold_out}\n\n" "$neovim_title" | indent 3
    printf "${bold_in}%s${bold_out}" "$neovim_install" | indent 5
    printf "${bold_in}%s${bold_out}\n\n" "$neovim_build" | indent 5
    # --------------------
    warning_bar "$install_halt"
    exit 2
  fi
}
# Beginning of functions for script unfolding
function backup_directories() {
  local root_dir="$1"
  local current_date
  local config="config"
  local share="local/share"
  current_date=$(date +%Y%m%d)
  local config_dir="$HOME/.config/$root_dir"
  local local_share_dir="$HOME/.local/share/$root_dir"
  local backup_dir="$HOME/backup/${root_dir}_backup_$current_date"
  # Create the backup directory if it doesn't exist
  mkdir -p "$backup_dir/$config/$root_dir"
  mkdir -p "$backup_dir/$share/$root_dir"
  # Backup the .config directory
  if [[ -d "$config_dir" ]]; then
    cp -r -f "$config_dir" "$backup_dir/$config/"
    printf "\n"
    printf "Backed up %s\n" "$config_dir" | indent 2
    printf "to ${green}%s${clear}\n" "${root_dir}_backup_$current_date/$config" | indent 3
  else
    printf "Warning: Source directory %s does not exist.\n" "$config_dir"
  fi
  # Backup the .local/share directory
  if [[ -d "$local_share_dir" ]]; then
    cp -r -f "$local_share_dir" "$backup_dir/$share/"
    printf "Backed up %s\n" "$local_share_dir" | indent 2
    printf "to ${green}%s${clear}\n" "${root_dir}_backup_$current_date/$share" | indent 3
  else
    printf "Warning: Source directory %s does not exist.\n" "$local_share_dir"
  fi
  printf "\n"
  printf "Backup completed successfully" | indent 2
  printf "\n"
  printf "Backup stored in: \n${orange}%s${clear}\n" "$backup_dir" | indent 3
}
# Functions for terminal printing of missing required packages
# 'commands' array of required packages to verify
commands=("git" "gcc" "make" "npm" "sqlite3" "rg" "lazygit")
# 'messages' array of messages related to missing packets
# NOTE: To function properly, the number of entries in 'command'
# must match the number of entries in 'messages'
messages=("sudo dnf install git -y" "sudo dnf install gcc -y" "sudo dnf install make -y" "sudo dnf install npm -y" "sudo dnf install sqlite -y" "Check the NOTE below" "Check the NOTE below")
function print_if_one_missing() {
  local msg="$1" # Capture the message passed as an argument
  missing_commands=()
  for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_commands+=("$cmd")
    fi
  done
  if [ ${#missing_commands[@]} -ne 0 ]; then
    local type=$1 # Take 'type' as a parameter to the function
    if [[ "$type" == "header" ]]; then
      divider_single_red
      center_bold_red "WARNING - Missing packages detected."
      divider_single_red
    elif [[ "$type" == "footer" ]]; then
      format_text "The packages in the list are necessary for the successful installation of the configuration; without their availability, the configuration cannot run properly. To install the missing packages on a Rocky Linux or RHEL system, simply run the suggested commands; if your system uses a different package manager, adapt the commands accordingly."
      printf "\n"
      press_enter_or_quit
      printf "\n"
    else
      echo "Invalid type specified. Please use 'header' or 'footer'."
    fi
  fi
}

# Function to check if all commands are installed
function print_if_all_installed() {
  local msg="$1" # Capture the message passed as an argument
  all_installed=true

  for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      all_installed=false
      break
    fi
  done

  if [ "$all_installed" = true ]; then
    format_text "$msg" # Print the message if all commands are installed
  fi
}
# Function for terminal printout the list of missing packages
# and their corresponding commands for installation
function print_list_missing() {
  printf "${bold_in}%-10s %-10s %-10s${bold_out}\n" "Package" "Status" "Install Cmd" | indent 2
  printf "%-10s %-10s %-40s\n" "-------" "------" "-----------" | indent 2
  for i in "${!commands[@]}"; do
    if command -v "${commands[i]}" &>/dev/null; then
      status="Installed"
      # exists="Yes"
      # message="${commands[i]} is installed."
      message="  ------  "
    else
      status="Missing"
      # exists="No"
      message="${messages[i]}"
    fi
    printf "%-10s %-10s ${bold_in}%-10s${bold_out}\n" "${commands[i]}" "${status}" "${message}" | indent 2
  done
}
# Function to print a custom message for each missing command
function print_missing_message() {
  local cmd=$1
  if ! command -v "$cmd" &>/dev/null; then
    case $cmd in
    git)
      printf "  ${bold_in}%s${bold_out}\n" "Git - version manager"
      format_text "This application is needed for version control of NvChad and installed plugins thus allowing them to be updated."
      printf "\n"
      ;;
    gcc)
      printf "  ${bold_in}%s${bold_out}\n" "GCC - GNU Compiler Collection"
      format_text "This collection of compilers is necessary for proper handling of plugins, their installation and updating."
      printf "\n"
      ;;
    make)
      printf "  ${bold_in}%s${bold_out}\n" "Make - compile and link a program"
      format_text "Required to build plugins written in C, required for proper operation of NvChad."
      printf "\n"
      ;;
    npm)
      printf "  ${bold_in}%s${bold_out}\n" "Npm - the standard package manager for Node.js."
      format_text "It started as a way to download and manage dependencies of Node.js packages, but it has since become a tool used also in frontend JavaScript."
      printf "\n"
      ;;
    sqlite3)
      printf "  ${bold_in}%s${bold_out}\n" "SQLite3 - SQL database engine"
      format_text "Lightweight, high-performance database used by the 'yanky.nvim' plugin to store saved strings. It allows handling of a larger number of strings without slowing down the search."
      printf "\n"
      ;;
    rg)
      printf "  ${bold_in}%s${bold_out}\n" "Ripgrep (rg) - line-oriented search tool"
      format_text "Used by telescope sorter to significantly improve sorting performance, for its installation the availability of Epel repository is required, to install it the commands are:"
      printf "\n"
      printf "${bold_in}%s${bold_out}\n" "sudo dnf install epel-release -y" | indent 2
      printf "${bold_in}%s${bold_out}\n" "sudo dnf install ripgrep -y" | indent 2
      printf "\n"
      ;;
    lazygit)
      printf "  ${bold_in}%s${bold_out}\n" "LazyGit - terminal UI for git commands"
      format_text "LazyGit allows you to perform all operations on Git repositories from a convenient ncurses interface, specifically the installed plugin allows you to perform all operations without leaving the editor. To install it run the following commands:"
      printf "\n"
      printf "${bold_in}%s${bold_out}\n" "sudo dnf copr enable atim/lazygit -y" | indent 2
      printf "${bold_in}%s${bold_out}\n" "sudo dnf lazygit -y" | indent 2
      printf "\n"
      ;;
    esac
  else
    return
  fi
}
# Function to remove markchad items with error handling
function remove_markchad() {
  # Define variables
  local tmp_dir="$HOME/.local/tmp"
  local tmp_name="markchad"
  local markchad_rm=("$tmp_dir/$tmp_name.tar.gz" "$tmp_dir/$tmp_name.tar.gz.sha256" "$tmp_dir/$tmp_name")
  section_title "Cleaning temporary files"
  for item in "${markchad_rm[@]}"; do
    if [[ -e "$item" ]]; then
      echo "Attempting to remove: $item..."
      rm -rf "$item" # Using -r to handle directories and -f to force removal
      local item_err=$?
      if [[ $item_err -eq 0 ]]; then
        echo "$item removed successfully."
      else
        echo "Error: Failed to remove $item."
        exit 1
      fi
    else
      echo "$item does not exist, no action taken."
    fi
  done
}
function divider() {
  printf -- "-%.0s" $(seq 1 80)
  printf "\n"
}
function divider_single_red() {
  printf -- "\033[0;31m-%.0s\e[0m" $(seq 1 80)
  printf "\n"
}
function divider_single_green() {
  printf -- "\e[32m-%.0s\e[0m" $(seq 1 80)
  printf "\n"
}
function divider_double_red() {
  printf "\033[0;31m=%.0s\e[0m" $(seq 1 80)
  printf "\n"
}
function indent() {
  local indentSize=2
  local indent=1
  if [ -n "$1" ]; then indent=$1; fi
  pr -to $((indent * indentSize))
}
# Loop until a key is pressed
function press_to_exit() {
  while true; do
    read -rsn1 key # Read a single character silently
    if [[ -n "$key" ]]; then
      printf "\n"
      exit
    fi
  done
}
# Function to prompt the user to press Enter to continue or 'q' to quit
press_enter_or_quit() {
  while true; do
    read -r -p "$enter_or_quit_info" input

    if [[ "$input" == "q" ]]; then
      printf "  %s\n" "$enter_or_quit_exit"
      printf "\n"
      exit 0
    elif [[ -z "$input" ]]; then
      return # Continue with the script
    else
      printf "  %s\n" "$enter_or_quit_wrong"
      printf "\n"
    fi
  done
}
# Function to format text
format_text() {
  local text="$1"
  # Use fold to limit line width and sed to add padding
  echo "$text" | fold -s -w 76 | sed 's/^/  /; s/$/  /'
}
# Function to center text
function center_bold_red() {
  local text="$1"
  local text_length=${#text}                # Get the length of the text
  local padding=$(((80 - text_length) / 2)) # Calculate padding
  # Print the text with padding
  printf "%${padding}s\033[1m\033[0;31m%s\e[0m\033[0m\n" "" "$text"
}
function warning_bar() {
  local text="$1"
  local text_length=${#text}                # Get the length of the text
  local padding=$(((80 - text_length) / 2)) # Calculate padding
  # Print the text with padding
  printf "\n"
  divider_single_red
  printf "%${padding}s\033[1m\033[0;31m%s\e[0m\033[0m\n" "" "$text"
  divider_single_red
  printf "\n"
}
function center_bold_green() {
  local text="$1"
  local text_length=${#text}                # Get the length of the text
  local padding=$(((80 - text_length) / 2)) # Calculate padding
  # Print the text with padding
  printf "%${padding}s\033[1m\e[32m%s\e[0m\033[0m\n" "" "$text"
}
# Function to center text with '=' padding
function title_red() {
  local text="$1"
  local total_width=80                               # Total width of the line
  local text_length=${#text}                         # Length of the text
  local padding=$(((total_width - text_length) / 2)) # Calculate padding
  # Create the line with '=' characters and center the text
  printf "%${padding}s" "=" | tr ' ' '='             # Left padding with '='
  printf " \033[1m\033[0;31m%s\e[0m\033[0m " "$text" # Print the text
  printf "%${padding}s" "=" | tr ' ' '='             # Right padding with '='
  echo ""                                            # New line
}
function title_green() {
  local text="$1"
  local total_width=80                               # Total width of the line
  local text_length=${#text}                         # Length of the text
  local padding=$(((total_width - text_length) / 2)) # Calculate padding
  # Create the line with '=' characters and center the text
  printf "%${padding}s" "=" | tr ' ' '='         # Left padding with '='
  printf " \033[1m\e[32m%s\e[0m\033[0m " "$text" # Print the text
  printf "%${padding}s" "=" | tr ' ' '='         # Right padding with '='
  echo ""                                        # New line
}
# Title
title_msg() {
  termwidth=80
  padding="$(printf '%0.1s' ={1..500})"
  printf "%*.*s \033[1m\x1b[38;5;214m%s\e[0m\033[0m %*.*s\n" 0 "$(((termwidth - 2 - ${#1}) / 2))" "$padding" "$1" 0 "$(((termwidth - 1 - ${#1}) / 2))" "$padding"
}
function print_centered_red_text() {
  local text="$1"

  # ANSI escape codes for red text
  local red="\e[31m"
  local reset="\e[0m"

  # Determine the total width and calculate padding
  local total_width=80
  local text_length=${#text}
  local padding=$(((total_width - text_length) / 2))

  # Create the left padded space
  local padded_text
  padded_text="$(printf "%*s%s" $padding "" "$text")"

  # Create the 80-character bar
  local bar
  bar=$(printf "%*s" "$total_width" | tr ' ' '-')

  # Print the red bar with the centered text
  printf "${red}%s${reset}\n" "$bar"
  printf "${red}%s${reset}\n" "$padded_text"
  printf "${red}%s${reset}\n" "$bar"
}
section_title() {
  local text="$1"
  local width=78 # Total width limit is set to 80 columns
  # Calculate the total spaces to fill
  local total_spaces=$((width - ${#text}))
  # If text is longer than 80 columns, truncate the text
  if ((total_spaces < 0)); then
    text="${text:0:width}"
    total_spaces=0
  fi
  # Create the dotted line
  local dots
  dots=$(printf "%${total_spaces}s" "." | tr " " ".")
  # Print the right-aligned text with dots on the left
  printf "%s\x1b[38;5;81m %s\e[0m\n" "$dots" "$text"
}
