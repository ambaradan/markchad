#!/bin/env bash
# Used only locally to eliminate ShellChek warnings
source ./messages
# Function to back up directories
backup_directories() {
  local root_dir="$1"
  local current_date
  local config="config"
  local share="local/share"
  current_date=$(date +%Y%m%d)
  local config_dir="$HOME/.config/$root_dir"
  local local_share_dir="$HOME/.local/share/$root_dir"
  local backup_dir="$HOME/backup/${root_dir}_backup_$current_date"
  # Create the backup directory if it doesn't exist
  mkdir -p "$backup_dir/$config/$root_dir"
  mkdir -p "$backup_dir/$share/$root_dir"
  # Backup the .config directory
  if [[ -d "$config_dir" ]]; then
    cp -r "$config_dir" "$backup_dir/$config/"
    printf "Backed up %s\n" "$config_dir"
    printf "to %s\n" "${root_dir}_backup_$current_date/$config"
  else
    printf "Warning: Source directory %s does not exist.\n" "$config_dir"
  fi
  # Backup the .local/share directory
  if [[ -d "$local_share_dir" ]]; then
    cp -r "$local_share_dir" "$backup_dir/$share/"
    printf "Backed up %s\n" "$local_share_dir"
    printf "to %s\n" "${root_dir}_backup_$current_date/$share"
  else
    printf "Warning: Source directory %s does not exist.\n" "$local_share_dir"
  fi

  printf "Backup completed successfully.\nBackup stored in: \n%s\n" "$backup_dir"
}
# Function to show header and footer if some command is missing
commands=("git" "gcc" "make" "rsync" "sqlite3" "rg" "lazygit")
messages=("sudo dnf install git -y" "sudo dnf install gcc -y" "sudo dnf install make -y" "sudo dnf install rsync -y" "sudo dnf install sqlite -y" "Check the NOTE below" "Check the NOTE below")
function print_if_one_missing() {
  local msg="$1" # Capture the message passed as an argument
  # commands=("git" "gcc" "make" "rsync" "sqlite3" "rg" "lazygit")
  missing_commands=()

  for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_commands+=("$cmd")
    fi
  done

  if [ ${#missing_commands[@]} -ne 0 ]; then
    local type=$1  # Take 'type' as a parameter to the function

    if [[ "$type" == "header" ]]; then
        echo "This is the header message."
    elif [[ "$type" == "footer" ]]; then
        echo "This is the footer message."
    else
        echo "Invalid type specified. Please use 'header' or 'footer'."
    fi
  fi
}

# Function to check if all commands are installed
function print_if_all_installed() {
  local msg="$1" # Capture the message passed as an argument
  all_installed=true

  for cmd in "${commands[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      all_installed=false
      break
    fi
  done

  if [ "$all_installed" = true ]; then
    format_text "$msg" # Print the message if all commands are installed
  fi
}
# Function for terminal printout the list of missing packages
# and their corresponding commands for installation
function print_list_missing() {
  printf "${bold_in}%-10s %-10s %-10s${bold_out}\n" "Package" "Status" "Install Cmd" | indent 2
  printf "%-10s %-10s %-40s\n" "-------" "------" "-----------" | indent 2
  for i in "${!commands[@]}"; do
    if command -v "${commands[i]}" &>/dev/null; then
      status="Installed"
      # exists="Yes"
      # message="${commands[i]} is installed."
      message="  ------  "
    else
      status="Missing"
      # exists="No"
      message="${messages[i]}"
    fi
    printf "%-10s %-10s ${bold_in}%-10s${bold_out}\n" "${commands[i]}" "${status}" "${message}" | indent 2
  done
}
# Function to print a custom message for each missing command
function print_missing_message() {
  local cmd=$1
  if ! command -v "$cmd" &>/dev/null; then
    case $cmd in
    git)
      printf "  ${bold_in}%s${bold_out}\n" "Git - version manager"
      format_text "This application is needed for version control of NvChad and installed plugins thus allowing them to be updated."
      printf "\n"
      ;;
    gcc)
      printf "  ${bold_in}%s${bold_out}\n" "GCC - GNU Compiler Collection"
      format_text "This collection of compilers is necessary for proper handling of plugins, their installation and updating."
      printf "\n"
      ;;
    make)
      printf "  ${bold_in}%s${bold_out}\n" "Make - compile and link a program"
      format_text "Required to build plugins written in C, required for proper operation of NvChad."
      printf "\n"
      ;;
    sqlite3)
      printf "  ${bold_in}%s${bold_out}\n" "SQLite3 - SQL database engine"
      format_text "Lightweight, high-performance database used by the 'yanky.nvim' plugin to store saved strings. It allows handling of a larger number of strings without slowing down the search."
      printf "\n"
      ;;
    rg)
      printf "  ${bold_in}%s${bold_out}\n" "Ripgrep (rg) - line-oriented search tool"
      format_text "Used by telescope sorter to significantly improve sorting performance, for its installation the availability of Epel repository is required, to install it the commands are:"
      printf "\n"
      printf "${bold_in}%s${bold_out}\n" "sudo dnf install epel-release -y" | indent 2
      printf "${bold_in}%s${bold_out}\n" "sudo dnf install ripgrep -y" | indent 2
      printf "\n"
      ;;
    lazygit)
      printf "  ${bold_in}%s${bold_out}\n" "LazyGit - terminal UI for git commands"
      format_text "LazyGit allows you to perform all operations on Git repositories from a convenient ncurses interface, specifically the installed plugin allows you to perform all operations without leaving the editor. To install it run the following commands:"
      printf "\n"
      printf "${bold_in}%s${bold_out}\n" "sudo dnf copr enable atim/lazygit -y" | indent 2
      printf "${bold_in}%s${bold_out}\n" "sudo dnf lazygit -y" | indent 2
      printf "\n"
      ;;
    esac
  else
    return
  fi
}

function divider() {
  printf -- "-%.0s" $(seq 1 80)
  printf "\n"
}
function divider_single_red() {
  printf -- "\033[0;31m-%.0s\e[0m" $(seq 1 80)
  printf "\n"
}
function divider_single_green() {
  printf -- "\e[32m-%.0s\e[0m" $(seq 1 80)
  printf "\n"
}
function divider_double_red() {
  printf "\033[0;31m=%.0s\e[0m" $(seq 1 80)
  printf "\n"
}
function indent() {
  local indentSize=2
  local indent=1
  if [ -n "$1" ]; then indent=$1; fi
  pr -to $((indent * indentSize))
}
# Loop until a key is pressed
function press_to_exit() {
  while true; do
    read -rsn1 key # Read a single character silently
    if [[ -n "$key" ]]; then
      printf "\n"
      exit
    fi
  done
}
# Function to prompt the user to press Enter to continue or 'q' to quit
press_enter_or_quit() {
  while true; do
    read -r -p "$enter_or_quit_info" input

    if [[ "$input" == "q" ]]; then
      printf "  %s\n" "$enter_or_quit_exit"
      printf "\n"
      exit 0
    elif [[ -z "$input" ]]; then
      return # Continue with the script
    else
      printf "  %s\n" "$enter_or_quit_wrong"
      printf "\n"
    fi
  done
}
# Function to draw a box around the text
draw_box() {
  local text="$1"
  local length=${#text}
  local border=$(printf "%${length}s" | tr ' ' '-')

  echo "+${border}+"
  echo "| ${text} |"
  echo "+${border}+"
}
# Function to format text
format_text() {
  local text="$1"
  # Use fold to limit line width and sed to add padding
  echo "$text" | fold -s -w 76 | sed 's/^/  /; s/$/  /'
}
# Function to center text
function center_bold_red() {
  local text="$1"
  local text_length=${#text}                # Get the length of the text
  local padding=$(((80 - text_length) / 2)) # Calculate padding
  # Print the text with padding
  printf "%${padding}s\033[1m\033[0;31m%s\e[0m\033[0m\n" "" "$text"
}
function warning_bar() {
  local text="$1"
  local text_length=${#text}                # Get the length of the text
  local padding=$(((80 - text_length) / 2)) # Calculate padding
  # Print the text with padding
  printf "\n"
  divider_single_red
  printf "%${padding}s\033[1m\033[0;31m%s\e[0m\033[0m\n" "" "$text"
  divider_single_red
  printf "\n"
}
function center_bold_green() {
  local text="$1"
  local text_length=${#text}                # Get the length of the text
  local padding=$(((80 - text_length) / 2)) # Calculate padding
  # Print the text with padding
  printf "%${padding}s\033[1m\e[32m%s\e[0m\033[0m\n" "" "$text"
}
# Function to center text with '=' padding
function title_red() {
  local text="$1"
  local total_width=80                               # Total width of the line
  local text_length=${#text}                         # Length of the text
  local padding=$(((total_width - text_length) / 2)) # Calculate padding
  # Create the line with '=' characters and center the text
  printf "%${padding}s" "=" | tr ' ' '='             # Left padding with '='
  printf " \033[1m\033[0;31m%s\e[0m\033[0m " "$text" # Print the text
  printf "%${padding}s" "=" | tr ' ' '='             # Right padding with '='
  echo ""                                            # New line
}
function title_green() {
  local text="$1"
  local total_width=80                               # Total width of the line
  local text_length=${#text}                         # Length of the text
  local padding=$(((total_width - text_length) / 2)) # Calculate padding
  # Create the line with '=' characters and center the text
  printf "%${padding}s" "=" | tr ' ' '='         # Left padding with '='
  printf " \033[1m\e[32m%s\e[0m\033[0m " "$text" # Print the text
  printf "%${padding}s" "=" | tr ' ' '='         # Right padding with '='
  echo ""                                        # New line
}
# Title
title_msg() {
  termwidth=80
  padding="$(printf '%0.1s' ={1..500})"
  printf "%*.*s \033[1m\x1b[38;5;214m%s\e[0m\033[0m %*.*s\n" 0 "$(((termwidth - 2 - ${#1}) / 2))" "$padding" "$1" 0 "$(((termwidth - 1 - ${#1}) / 2))" "$padding"
}
function print_centered_red_text() {
  local text="$1"

  # ANSI escape codes for red text
  local red="\e[31m"
  local reset="\e[0m"

  # Determine the total width and calculate padding
  local total_width=80
  local text_length=${#text}
  local padding=$(((total_width - text_length) / 2))

  # Create the left padded space
  local padded_text
  padded_text="$(printf "%*s%s" $padding "" "$text")"

  # Create the 80-character bar
  local bar
  bar=$(printf "%*s" "$total_width" | tr ' ' '-')

  # Print the red bar with the centered text
  printf "${red}%s${reset}\n" "$bar"
  printf "${red}%s${reset}\n" "$padded_text"
  printf "${red}%s${reset}\n" "$bar"
}
section_title() {
  local text="$1"
  local width=78 # Total width limit is set to 80 columns
  # Calculate the total spaces to fill
  local total_spaces=$((width - ${#text}))
  # If text is longer than 80 columns, truncate the text
  if ((total_spaces < 0)); then
    text="${text:0:width}"
    total_spaces=0
  fi
  # Create the dotted line
  local dots
  dots=$(printf "%${total_spaces}s" "." | tr " " ".")
  # Print the right-aligned text with dots on the left
  printf "%s\x1b[38;5;81m %s\e[0m\n" "$dots" "$text"
}
